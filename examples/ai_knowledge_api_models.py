# generated by datamodel-codegen:
#   filename:  https://backend-api.dev.ai-knowledge.aws.inform-cloud.io/openapi.json
#   timestamp: 2025-10-27T11:43:24+00:00

from __future__ import annotations

from datetime import date, datetime
from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import BaseModel, Extra, Field, SecretStr, conint, constr


class AuthenticationScheme(Enum):
    Basic = 'Basic'


class BasicAuthentication(BaseModel):
    class Config:
        extra = Extra.forbid

    authenticationScheme: Optional[AuthenticationScheme] = Field(
        'Basic',
        description='The authentication scheme used for the website.',
        title='Authenticationscheme',
    )
    username: str = Field(
        ..., description='Username for basic authentication.', title='Username'
    )
    password: SecretStr = Field(
        ..., description='Password for basic authentication.', title='Password'
    )


class AuthenticationScheme1(Enum):
    Bearer = 'Bearer'


class BearerAuthentication(BaseModel):
    class Config:
        extra = Extra.forbid

    authenticationScheme: Optional[AuthenticationScheme1] = Field(
        'Bearer',
        description='The authentication scheme used for the website.',
        title='Authenticationscheme',
    )
    token: SecretStr = Field(
        ..., description='Bearer token for authentication.', title='Token'
    )


class Model(Enum):
    cohere_embed_multilingual_v3 = 'cohere.embed-multilingual-v3'


class Provider(Enum):
    bedrock = 'bedrock'


class BedrockEmbedding(BaseModel):
    model: Optional[Model] = Field(
        'cohere.embed-multilingual-v3',
        description='The Cohere embedding model to be used.',
        title='Model',
    )
    provider: Optional[Provider] = Field(
        'bedrock', description='The provider of the embedding model.', title='Provider'
    )
    dimensions: Optional[conint(ge=1)] = Field(
        None,
        description="The number of dimensions of the embedding. If not specified, uses the model's default.",
        title='Dimensions',
    )


class ChunkType(Enum):
    CharacterChunker = 'CharacterChunker'


class CharacterChunker(BaseModel):
    class Config:
        extra = Extra.forbid

    chunkType: Optional[ChunkType] = Field('CharacterChunker', title='Chunktype')
    chunkSize: Optional[conint(ge=1, le=40000)] = Field(
        2000, description='The length of each chunk.', title='Chunksize'
    )
    overlap: Optional[conint(ge=0)] = Field(
        500,
        description='The number of characters that overlap between chunks.',
        title='Overlap',
    )
    minLength: Optional[conint(ge=0)] = Field(
        0, description='The minimum length of each chunk.', title='Minlength'
    )


class Source(BaseModel):
    __root__: constr(regex=r'^[a-zA-Z0-9-_]+$', min_length=0, max_length=255) = Field(
        ..., description='A list of source identifiers associated with the collection.'
    )


class CollectionUsageSummary(BaseModel):
    indexRunsSuccessful: int = Field(
        ...,
        description='Total number of successful index runs',
        title='Indexrunssuccessful',
    )
    indexRunsFailed: int = Field(
        ..., description='Total number of failed index runs', title='Indexrunsfailed'
    )
    queriesSuccessful: int = Field(
        ..., description='Total number of successful queries', title='Queriessuccessful'
    )
    queriesFailed: int = Field(
        ..., description='Total number of failed queries', title='Queriesfailed'
    )
    documentsProcessed: int = Field(
        ...,
        description='Total number of processed documents',
        title='Documentsprocessed',
    )
    embeddedFragments: int = Field(
        ..., description='Total number of embedded fragments', title='Embeddedfragments'
    )
    totalTokens: int = Field(
        ..., description='Total number of tokens used', title='Totaltokens'
    )
    totalCosts: str = Field(..., description='Total costs incurred', title='Totalcosts')


class CreateCollectionResponse(BaseModel):
    message: str = Field(
        ...,
        description='The message indicating the result of the operation.',
        title='Message',
    )


class CreateSourceResponse(BaseModel):
    message: str = Field(
        ...,
        description='The message indicating the result of the operation.',
        title='Message',
    )


class DeleteCollectionResponse(BaseModel):
    message: str = Field(
        ...,
        description='The message indicating the result of the operation.',
        title='Message',
    )


class DeleteS3Response(BaseModel):
    class Config:
        extra = Extra.forbid

    message: str = Field(
        ..., description='Message providing additional information', title='Message'
    )


class DeleteSourceResponse(BaseModel):
    message: str = Field(
        ...,
        description='The message indicating the result of the operation.',
        title='Message',
    )


class DistanceFunctionEnum(Enum):
    cosine = 'cosine'
    inner_product = 'inner product'
    l1 = 'l1'
    l2 = 'l2'
    hamming = 'hamming'
    jaccard = 'jaccard'


class DocumentContentResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    textContent: str = Field(
        ..., description='The text content of the document', title='Textcontent'
    )
    nextToken: Optional[str] = Field(
        None,
        description='The next token to retrieve the next characters.',
        title='Nexttoken',
    )


class DocumentMetrics(BaseModel):
    processedTotal: Optional[int] = Field(
        0, description='Total number of documents processed.', title='Processedtotal'
    )
    added: Optional[int] = Field(
        0, description='Number of documents added.', title='Added'
    )
    edited: Optional[int] = Field(
        0, description='Number of documents edited.', title='Edited'
    )
    deleted: Optional[int] = Field(
        0, description='Number of documents deleted.', title='Deleted'
    )
    errors: Optional[int] = Field(
        0, description='Number of errors encountered during processing.', title='Errors'
    )
    fragmentsEmbedded: Optional[int] = Field(
        0, description='Number of fragments embedded.', title='Fragmentsembedded'
    )


class PluginScope(Enum):
    document = 'document'


class PluginType(Enum):
    document_summary = 'document_summary'


class AllowFailure(Enum):
    boolean_False = False


class ExecutionMode(Enum):
    sequential = 'sequential'


class SummarizationModel(Enum):
    gpt_4o = 'gpt-4o'
    gpt_4o_mini = 'gpt-4o-mini'


class ReductionModel(Enum):
    gpt_4o = 'gpt-4o'
    gpt_4o_mini = 'gpt-4o-mini'


class DocumentSummaryPluginConfig(BaseModel):
    pluginScope: Optional[PluginScope] = Field('document', title='Pluginscope')
    pluginType: Optional[PluginType] = Field('document_summary', title='Plugintype')
    pluginName: str = Field(
        ...,
        description='A unique name to identify the plugin instance by.',
        title='Pluginname',
    )
    allowFailure: Optional[AllowFailure] = Field(
        False,
        description='Flag whether a failure of a plugin should mark processing as failed. Currently this flag is not supported!',
        title='Allowfailure',
    )
    executionMode: Optional[ExecutionMode] = Field(
        'sequential',
        description='Defines whether execution order of plugins should be guaranteed. Set to sequential if other plugins or processes depend on the execution of this plugin.',
        title='Executionmode',
    )
    summarizationModel: Optional[SummarizationModel] = Field(
        'gpt-4o-mini',
        description='The language model used to summarize document text.',
        title='Summarizationmodel',
    )
    reductionModel: Optional[ReductionModel] = Field(
        'gpt-4o-mini',
        description='The language model used to combine partial summaries in case the document can not be summarized in one piece.',
        title='Reductionmodel',
    )
    summarizationPrompt: Optional[str] = Field(
        '\nYou are a content summarizer. You will be given a block of text from a document.\nBriefly summarize its contents in fewer than 480 characters.\nYour summary should identify the type of document and the general topics it covers.\nDo not include specific arguments, detailed points, or quotes.\nFocus only on the overall subject matter and purpose of the text.\nRespond in English only.\n',
        description='The instructions to summarize the document text.',
        title='Summarizationprompt',
    )
    reductionPrompt: Optional[str] = Field(
        '\nYou are a content summary condenser. You will be given multiple partial summaries\nof a larger document. Combine these into a single coherent summary that does not exceed\n480 characters. Your final summary should clearly state what type of document\nit is and outline the general topics it covers.\nFocus on presenting a unified overview.\nRespond in English only.\n',
        description='The instructions to combine multiple partial summaries.',
        title='Reductionprompt',
    )
    chunkSize: Optional[int] = Field(
        100000,
        description='The size of the chunks to be summarized.',
        title='Chunksize',
    )
    metadataKey: Optional[str] = Field(
        'summary',
        description='The key in the metadata store where summaries are stored.',
        title='Metadatakey',
    )


class ErrorResponse(BaseModel):
    detail: str = Field(..., description='Error message', title='Detail')


class FragmentCountsResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    totalFragments: int = Field(
        ..., description='Total number of fragments', title='Totalfragments'
    )
    documentFragments: Dict[str, int] = Field(
        ...,
        description='Dictionary mapping document IDs to their fragment counts',
        title='Documentfragments',
    )


class FragmentMetadata(BaseModel):
    class Config:
        extra = Extra.allow

    startIndex: Optional[int] = Field(
        0,
        description='The start index of the fragment in the document.',
        title='Startindex',
    )
    length: Optional[int] = Field(
        0, description='The length of the fragment.', title='Length'
    )


class GetPresignedUrlResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    url: str = Field(
        ..., description='Presigned URL for uploading a file to S3', title='Url'
    )


class SourceType(Enum):
    github = 'github'


class GithubSourcePropertiesInput(BaseModel):
    class Config:
        extra = Extra.forbid

    prefix: Optional[List[str]] = Field(
        [],
        description='A list of prefixes to filter objects in the source.',
        max_items=32,
        min_items=0,
        title='Prefix',
    )
    suffix: Optional[List[str]] = Field(
        [],
        description='A list of suffixes to filter objects in the source.',
        max_items=32,
        min_items=0,
        title='Suffix',
    )
    prefixIgnore: Optional[List[str]] = Field(
        [],
        description='A list of prefixes to filter objects in the source to be ignored.',
        max_items=32,
        min_items=0,
        title='Prefixignore',
    )
    suffixIgnore: Optional[List[str]] = Field(
        [],
        description='A list of suffixes to filter objects in the source to be ignored.',
        max_items=32,
        min_items=0,
        title='Suffixignore',
    )
    sourceType: Literal['github'] = Field(
        ...,
        description="The type of the source, which is 'github' for this model.",
        title='Sourcetype',
    )
    organization: str = Field(
        ...,
        description='The name of the github organization where the repository is located.',
        title='Organization',
    )
    repository: str = Field(
        ..., description='The name of the github repository.', title='Repository'
    )
    personalAccessToken: Optional[SecretStr] = Field(
        None,
        description='The personal access token for the github repository. This token requires read access to the repository.',
        title='Personalaccesstoken',
    )
    branch: Optional[str] = Field(
        'main',
        description='The branch of the repository to extract information from.',
        title='Branch',
    )


class GithubSourcePropertiesOutput(BaseModel):
    class Config:
        extra = Extra.forbid

    prefix: Optional[List[str]] = Field(
        [],
        description='A list of prefixes to filter objects in the source.',
        max_items=32,
        min_items=0,
        title='Prefix',
    )
    suffix: Optional[List[str]] = Field(
        [],
        description='A list of suffixes to filter objects in the source.',
        max_items=32,
        min_items=0,
        title='Suffix',
    )
    prefixIgnore: Optional[List[str]] = Field(
        [],
        description='A list of prefixes to filter objects in the source to be ignored.',
        max_items=32,
        min_items=0,
        title='Prefixignore',
    )
    suffixIgnore: Optional[List[str]] = Field(
        [],
        description='A list of suffixes to filter objects in the source to be ignored.',
        max_items=32,
        min_items=0,
        title='Suffixignore',
    )
    sourceType: Literal['github'] = Field(
        ...,
        description="The type of the source, which is 'github' for this model.",
        title='Sourcetype',
    )
    organization: str = Field(
        ...,
        description='The name of the github organization where the repository is located.',
        title='Organization',
    )
    repository: str = Field(
        ..., description='The name of the github repository.', title='Repository'
    )
    personalAccessToken: Optional[str] = Field(
        None,
        description='The personal access token for the github repository. This token requires read access to the repository.',
        title='Personalaccesstoken',
    )
    branch: Optional[str] = Field(
        'main',
        description='The branch of the repository to extract information from.',
        title='Branch',
    )


class IndexCollectionResponse(BaseModel):
    message: str = Field(
        ...,
        description='The message indicating the result of the operation.',
        title='Message',
    )
    indexRunId: str = Field(
        ..., description='The ID of the index run.', title='Indexrunid'
    )
    triggeredSources: Optional[List[str]] = Field(
        None,
        description='List of sources that were triggered for indexing.',
        title='Triggeredsources',
    )
    traceId: Optional[str] = Field(
        None,
        description='Trace ID for distributed tracing. If not provided, it will be set to None.',
        title='Traceid',
    )


class IndexOperationStats(BaseModel):
    countTotal: Optional[conint(ge=0)] = Field(
        0, description='Total number of operations', title='Counttotal'
    )
    countSuccess: Optional[conint(ge=0)] = Field(
        0, description='Number of successful operations', title='Countsuccess'
    )
    countFailure: Optional[conint(ge=0)] = Field(
        0, description='Number of failed operations', title='Countfailure'
    )
    indexRuns: Optional[Dict[str, str]] = Field(
        None,
        description='Mapping of unique index run IDs to their status',
        title='Indexruns',
    )
    documentsProcessed: Optional[conint(ge=0)] = Field(
        0,
        description='Total number of documents processed during indexing',
        title='Documentsprocessed',
    )
    embeddedFragments: Optional[conint(ge=0)] = Field(
        0,
        description='Total number of embedded fragments during indexing',
        title='Embeddedfragments',
    )
    totalTokens: Optional[conint(ge=0)] = Field(
        0,
        description='Total number of tokens used during indexing',
        title='Totaltokens',
    )
    totalCosts: Optional[str] = Field(
        '0.0', description='Total costs incurred during indexing', title='Totalcosts'
    )
    successRate: str = Field(
        ...,
        description='Calculate the success rate.\n\nReturns\n-------\nDecimal\n    Success rate between 0.0 and 1.0 as a percentage of total operations.',
        title='Successrate',
    )


class TaskStatus(Enum):
    started = 'started'
    completed = 'completed'
    failed = 'failed'


class Trigger1(Enum):
    manual = 'manual'
    scheduled = 'scheduled'


class IndexRunProgressResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    documentsToProcess: Optional[int] = Field(
        None,
        description='Total number of documents to process in this run',
        title='Documentstoprocess',
    )
    documentsProcessed: Optional[int] = Field(
        0,
        description='Number of documents that have been processed so far',
        title='Documentsprocessed',
    )
    errors: Optional[int] = Field(
        0, description='Number of errors encountered during processing', title='Errors'
    )
    progressInPercent: Optional[float] = Field(
        0, description='Processing progress as a percentage', title='Progressinpercent'
    )
    estimatedTimeRemaining: Optional[int] = Field(
        None,
        description='Estimated time remaining in seconds',
        title='Estimatedtimeremaining',
    )


class Operation(Enum):
    add = 'add'
    edit = 'edit'
    delete = 'delete'


class IndexRunTaskItem(BaseModel):
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Additional metadata for the task', title='Metadata'
    )
    task: str = Field(..., description='The type of task', title='Task')
    indexRunId: str = Field(
        ..., description='The ID of the index run', title='Indexrunid'
    )
    datetimeExecution: datetime = Field(
        ...,
        description='The datetime (isoformat) when the task was executed.',
        example='2025-02-13T09:44:22.665141+00:00',
        title='Datetimeexecution',
    )
    fragmentId: Optional[str] = Field(
        None, description='The ID of the fragment (if applicable)', title='Fragmentid'
    )
    documentId: Optional[str] = Field(
        None, description='The ID of the document (if applicable)', title='Documentid'
    )
    operation: Optional[Operation] = Field(
        None,
        description='Operation performed on the document (add, edit, delete)',
        title='Operation',
    )
    taskStatus: TaskStatus = Field(
        ..., description='The status of the task', title='Taskstatus'
    )
    sourceId: Optional[str] = Field(
        None, description='The ID of the source (if applicable)', title='Sourceid'
    )
    collectionId: str = Field(
        ..., description='The ID of the collection', title='Collectionid'
    )
    traceId: Optional[str] = Field(
        None,
        description='Trace ID for distributed tracing. If not provided, it will be set to None.',
        title='Traceid',
    )


class InfoResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    sourceRoleArn: str = Field(
        ...,
        description='The AWS ARN of the role to grant s3 access to an external account.',
        example='arn:aws:iam::123456789012:role/role-name',
        title='Sourcerolearn',
    )
    supportedFileTypes: List[str] = Field(
        ...,
        description='List of supported file types.',
        example=['.docx', '.pptx', '.pdf', '.jpg', '.jpeg', '.png', '.bmp', '.tiff'],
        title='Supportedfiletypes',
    )


class ListCollectionsItem(BaseModel):
    collectionId: str = Field(
        ..., description='The collectionId.', title='Collectionid'
    )
    description: Optional[str] = Field(
        None, description='The description of the collection.', title='Description'
    )
    sources: Optional[List[str]] = Field(
        None,
        description="The source ID's of the collection.",
        max_items=16,
        min_items=0,
        title='Sources',
    )
    public: bool = Field(
        ...,
        description='Flag indicating if the source is publically accessible.',
        title='Public',
    )
    embeddingModel: str = Field(
        ...,
        description='The embedding model used for the collection.',
        title='Embeddingmodel',
    )
    projectNumber: Optional[constr(regex=r'^(00000|[1-9]\d{4}|1\d{5})$')] = Field(
        '00000',
        description='Project number related to the collection. This number is used to derive the business department (GB) and to allocate costs.',
        example='121300',
        title='Projectnumber',
    )
    nextScheduledIndexRun: Optional[Union[datetime, str]] = Field(
        None,
        description='The next scheduled index run.',
        example='2025-02-13T09:44:22.665141+00:00',
        title='Nextscheduledindexrun',
    )
    lastIndexRun: Optional[datetime] = Field(
        None,
        description='The last index run.',
        example='2025-02-13T09:44:22.665141+00:00',
        title='Lastindexrun',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Additional metadata for the collection.', title='Metadata'
    )
    accessDenied: Optional[bool] = Field(
        False,
        description='Flag indicating if access to the source is denied.',
        title='Accessdenied',
    )
    businessDepartment: str = Field(
        ...,
        description='Get the business department (GB) based on the project number.\n\nReturns\n-------\nstr\n    The business department (GB) derived from the project number.',
        title='Businessdepartment',
    )


class ListCollectionsResponse(BaseModel):
    Count: int = Field(
        ..., description='The number of items in the list', title='Count'
    )
    ScannedCount: int = Field(
        ..., description='The number of items scanned', title='Scannedcount'
    )
    TotalCount: int = Field(
        ...,
        description='The total number of items for the given query.',
        title='Totalcount',
    )
    Items: List[ListCollectionsItem] = Field(
        ..., description='The list of collections', max_items=1000, title='Items'
    )
    NextToken: Optional[str] = Field(
        None, description='The next token to retrieve the next page.', title='Nexttoken'
    )


class ListIndexRunTasksResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    Count: int = Field(
        ..., description='Number of items returned in the response', title='Count'
    )
    ScannedCount: int = Field(
        ...,
        description='Number of items evaluated in the database',
        title='Scannedcount',
    )
    TotalCount: int = Field(
        ...,
        description='Total number of items matching the query criteria',
        title='Totalcount',
    )
    Items: List[IndexRunTaskItem] = Field(
        ..., description='List of index run items', title='Items'
    )
    NextToken: Optional[str] = Field(
        None,
        description='Token for retrieving the next page of results',
        title='Nexttoken',
    )


class ListSourcesItem(BaseModel):
    sourceId: str = Field(..., description='The sourceId.', title='Sourceid')
    sourceType: str = Field(
        ..., description='The type of the source.', title='Sourcetype'
    )
    description: Optional[str] = Field(
        None, description='The description of the source.', title='Description'
    )
    public: bool = Field(
        ...,
        description='Flag indicating if the source is publicly accessible.',
        title='Public',
    )
    accessDenied: Optional[bool] = Field(
        False,
        description='Flag indicating if access to the source is denied.',
        title='Accessdenied',
    )


class ListSourcesResponse(BaseModel):
    Count: int = Field(
        ..., description='The number of items in the list', title='Count'
    )
    ScannedCount: int = Field(
        ..., description='The number of items scanned', title='Scannedcount'
    )
    TotalCount: int = Field(
        ...,
        description='The total number of items for the given query.',
        title='Totalcount',
    )
    Items: List[ListSourcesItem] = Field(
        ..., description='The list of sources', max_items=1000, title='Items'
    )
    NextToken: Optional[str] = Field(
        None, description='The next token to retrieve the next page.', title='Nexttoken'
    )


class Model1(Enum):
    mock_embedding_model = 'mock-embedding-model'


class Provider1(Enum):
    mock = 'mock'


class MockEmbedding(BaseModel):
    model: Optional[Model1] = Field(
        'mock-embedding-model', description='The mock embedding model.', title='Model'
    )
    provider: Optional[Provider1] = Field(
        'mock', description='The provider of the embedding model.', title='Provider'
    )
    dimensions: Optional[int] = Field(
        1024, description='The dimensions of the embedding vectors.', title='Dimensions'
    )


class Model2(Enum):
    text_embedding_ada_002 = 'text-embedding-ada-002'
    text_embedding_3_large = 'text-embedding-3-large'


class Provider2(Enum):
    openai = 'openai'


class OpenAIEmbedding(BaseModel):
    model: Optional[Model2] = Field(
        'text-embedding-ada-002',
        description='The OpenAI embedding model to be used.',
        title='Model',
    )
    provider: Optional[Provider2] = Field(
        'openai', description='The provider of the embedding model.', title='Provider'
    )
    dimensions: Optional[conint(ge=1)] = Field(
        None,
        description="The number of dimensions of the embedding. If not specified, uses the model's default.",
        title='Dimensions',
    )


class PermissionData(BaseModel):
    id: str = Field(..., description='internal name of the permission', title='Id')
    short: str = Field(..., description='short name of the permission', title='Short')
    long: str = Field(
        ..., description='longer description of the permission', title='Long'
    )
    granted: bool = Field(
        ...,
        description='flag indicating whether the permission is granted',
        title='Granted',
    )


class PermissionRoleRequest(BaseModel):
    resource_name: str = Field(
        ..., description='Name of the resource', title='Resource Name'
    )
    role: str = Field(..., description='Name of the role to update', title='Role')
    permission: str = Field(
        ..., description='ID of the permission to add or remove', title='Permission'
    )


class PluginInfo(BaseModel):
    pluginName: str = Field(..., description='Name of the plugin', title='Pluginname')
    pluginType: str = Field(..., description='Type of the plugin', title='Plugintype')
    pluginResult: str = Field(
        ..., description='Result of the plugin execution', title='Pluginresult'
    )


class QueryMetadata(BaseModel):
    class Config:
        extra = Extra.allow

    startIndex: int = Field(
        ..., description='Start index of the metadata', title='Startindex'
    )
    length: int = Field(..., description='Length of the metadata', title='Length')


class QueryOperationStats(BaseModel):
    countTotal: Optional[conint(ge=0)] = Field(
        0, description='Total number of operations', title='Counttotal'
    )
    countSuccess: Optional[conint(ge=0)] = Field(
        0, description='Number of successful operations', title='Countsuccess'
    )
    countFailure: Optional[conint(ge=0)] = Field(
        0, description='Number of failed operations', title='Countfailure'
    )
    promptTokens: Optional[conint(ge=0)] = Field(
        0,
        description='Total number of prompt tokens used during querying',
        title='Prompttokens',
    )
    promptCosts: Optional[str] = Field(
        '0.0',
        description='Total prompt costs incurred during indexing',
        title='Promptcosts',
    )
    successRate: str = Field(
        ...,
        description='Calculate the success rate.\n\nReturns\n-------\nDecimal\n    Success rate between 0.0 and 1.0 as a percentage of total operations.',
        title='Successrate',
    )
    totalTokens: int = Field(
        ...,
        description='Calculate the total tokens used in query operations.\n\nReturns\n-------\nint\n    Total number of tokens used in query operations.',
        title='Totaltokens',
    )
    totalCosts: str = Field(
        ...,
        description='Calculate the total costs incurred in query operations.\n\nReturns\n-------\nDecimal\n    Total costs incurred in query operations.',
        title='Totalcosts',
    )


class QueryRequestBody(BaseModel):
    text: str = Field(
        ..., description='Text to query against the collection.', title='Text'
    )


class QueryResponseItem(BaseModel):
    class Config:
        extra = Extra.forbid

    fragmentId: str = Field(..., description='ID of the fragment', title='Fragmentid')
    collectionId: str = Field(
        ..., description='ID of the collection', title='Collectionid'
    )
    documentName: str = Field(
        ..., description='Name of the document', title='Documentname'
    )
    documentUrl: Optional[str] = Field(
        None, description='URL of the original document', title='Documenturl'
    )
    documentUrlReference: Optional[str] = Field(
        None,
        description='URL of the reference document in AI Knowledge',
        title='Documenturlreference',
    )
    documentDisplayName: Optional[str] = Field(
        None, description='Display name of the document', title='Documentdisplayname'
    )
    sourceId: str = Field(..., description='ID of the source', title='Sourceid')
    lastModifiedTimestamp: datetime = Field(
        ...,
        description='Timestamp when the fragment was last modified',
        title='Lastmodifiedtimestamp',
    )
    content: str = Field(..., description='The fragment content', title='Content')
    distance: float = Field(
        ..., description='Similarity distance value', title='Distance'
    )
    metadata: Optional[QueryMetadata] = Field(
        None, description='Metadata for the fragment'
    )


class RoleData(BaseModel):
    role: str = Field(..., description='name of the role', title='Role')
    members: List[str] = Field(
        ..., description='list of users in the role', title='Members'
    )
    permissions: List[PermissionData] = Field(
        ...,
        description='list of permissions: pair or name of granted flag',
        title='Permissions',
    )


class RoleRequest(BaseModel):
    resource_name: str = Field(
        ..., description='Name of the resource', title='Resource Name'
    )
    role: str = Field(..., description='Name of the role to update', title='Role')


class SourceType2(Enum):
    s3 = 's3'


class S3SourcePropertiesInput(BaseModel):
    class Config:
        extra = Extra.forbid

    prefix: Optional[List[str]] = Field(
        [],
        description='A list of prefixes to filter objects in the source.',
        max_items=32,
        min_items=0,
        title='Prefix',
    )
    suffix: Optional[List[str]] = Field(
        [],
        description='A list of suffixes to filter objects in the source.',
        max_items=32,
        min_items=0,
        title='Suffix',
    )
    prefixIgnore: Optional[List[str]] = Field(
        [],
        description='A list of prefixes to filter objects in the source to be ignored.',
        max_items=32,
        min_items=0,
        title='Prefixignore',
    )
    suffixIgnore: Optional[List[str]] = Field(
        [],
        description='A list of suffixes to filter objects in the source to be ignored.',
        max_items=32,
        min_items=0,
        title='Suffixignore',
    )
    sourceType: Literal['s3'] = Field(
        ...,
        description="The type of the source, which is 's3' for this model.",
        title='Sourcetype',
    )
    bucketName: str = Field(
        ..., description='The name of the S3 bucket.', title='Bucketname'
    )
    allowFileUpload: Optional[bool] = Field(
        False,
        description='Flag indicating if file upload is allowed for this source.',
        title='Allowfileupload',
    )
    accessKeyId: Optional[SecretStr] = Field(
        None, description='The access key ID for the S3 bucket.', title='Accesskeyid'
    )
    secretAccessKey: Optional[SecretStr] = Field(
        None,
        description='The secret access key for the S3 bucket.',
        title='Secretaccesskey',
    )
    roleArn: Optional[SecretStr] = Field(
        None, description='The role ARN to access the S3 bucket.', title='Rolearn'
    )


class S3SourcePropertiesOutput(BaseModel):
    class Config:
        extra = Extra.forbid

    prefix: Optional[List[str]] = Field(
        [],
        description='A list of prefixes to filter objects in the source.',
        max_items=32,
        min_items=0,
        title='Prefix',
    )
    suffix: Optional[List[str]] = Field(
        [],
        description='A list of suffixes to filter objects in the source.',
        max_items=32,
        min_items=0,
        title='Suffix',
    )
    prefixIgnore: Optional[List[str]] = Field(
        [],
        description='A list of prefixes to filter objects in the source to be ignored.',
        max_items=32,
        min_items=0,
        title='Prefixignore',
    )
    suffixIgnore: Optional[List[str]] = Field(
        [],
        description='A list of suffixes to filter objects in the source to be ignored.',
        max_items=32,
        min_items=0,
        title='Suffixignore',
    )
    sourceType: Literal['s3'] = Field(
        ...,
        description="The type of the source, which is 's3' for this model.",
        title='Sourcetype',
    )
    bucketName: str = Field(
        ..., description='The name of the S3 bucket.', title='Bucketname'
    )
    allowFileUpload: Optional[bool] = Field(
        False,
        description='Flag indicating if file upload is allowed for this source.',
        title='Allowfileupload',
    )
    accessKeyId: Optional[str] = Field(
        None, description='The access key ID for the S3 bucket.', title='Accesskeyid'
    )
    secretAccessKey: Optional[str] = Field(
        None,
        description='The secret access key for the S3 bucket.',
        title='Secretaccesskey',
    )
    roleArn: Optional[str] = Field(
        None, description='The role ARN to access the S3 bucket.', title='Rolearn'
    )


class DatabaseType(Enum):
    s3_vector_bucket = 's3-vector-bucket'


class S3VectorBucket(BaseModel):
    databaseType: Literal['s3-vector-bucket'] = Field(..., title='Databasetype')


class IndexType(Enum):
    hnsw = 'hnsw'


class SearchIndexHNSW(BaseModel):
    class Config:
        extra = Extra.forbid

    indexType: Optional[IndexType] = Field(
        'hnsw', description='The type of the index.', title='Indextype'
    )
    distanceFunction: Optional[DistanceFunctionEnum] = Field(
        'cosine',
        description='The distance function used for the index.',
        example='cosine',
    )
    numberOfConnections: Optional[conint(ge=1, le=512)] = Field(
        16,
        description='The max number of connections per layer (16 by default). A higher value improves search efficiency by increasing graph connectivity but at the cost of more memory and longer construction times.',
        example=32,
        title='Numberofconnections',
    )
    efConstruction: Optional[conint(ge=1, le=512)] = Field(
        64,
        description='The size of the dynamic candidate list for constructing the graph (64 by default). A higher value of ef_construction provides better recall at the cost of index build time / insert speed.',
        example=64,
        title='Efconstruction',
    )
    dynamicCandidateSize: Optional[conint(ge=1, le=512)] = Field(
        40,
        description='The size of the dynamic candidate list for searching the graph (40 by default). A higher value provides better recall at the cost of speed.',
        example=64,
        title='Dynamiccandidatesize',
    )


class SourceType4(Enum):
    sharepoint = 'sharepoint'


class SharepointSourcePropertiesInput(BaseModel):
    class Config:
        extra = Extra.forbid

    prefix: Optional[List[str]] = Field(
        [],
        description='A list of prefixes to filter objects in the source.',
        max_items=32,
        min_items=0,
        title='Prefix',
    )
    suffix: Optional[List[str]] = Field(
        [],
        description='A list of suffixes to filter objects in the source.',
        max_items=32,
        min_items=0,
        title='Suffix',
    )
    prefixIgnore: Optional[List[str]] = Field(
        [],
        description='A list of prefixes to filter objects in the source to be ignored.',
        max_items=32,
        min_items=0,
        title='Prefixignore',
    )
    suffixIgnore: Optional[List[str]] = Field(
        [],
        description='A list of suffixes to filter objects in the source to be ignored.',
        max_items=32,
        min_items=0,
        title='Suffixignore',
    )
    sourceType: Literal['sharepoint'] = Field(
        ...,
        description="The type of the source, which is 'sharepoint' for this model.",
        title='Sourcetype',
    )
    sharingUrl: Optional[SecretStr] = Field(
        None,
        description='The sharing URL of the Sharepoint / One-Drive directory.',
        title='Sharingurl',
    )


class SharepointSourcePropertiesOutput(BaseModel):
    class Config:
        extra = Extra.forbid

    prefix: Optional[List[str]] = Field(
        [],
        description='A list of prefixes to filter objects in the source.',
        max_items=32,
        min_items=0,
        title='Prefix',
    )
    suffix: Optional[List[str]] = Field(
        [],
        description='A list of suffixes to filter objects in the source.',
        max_items=32,
        min_items=0,
        title='Suffix',
    )
    prefixIgnore: Optional[List[str]] = Field(
        [],
        description='A list of prefixes to filter objects in the source to be ignored.',
        max_items=32,
        min_items=0,
        title='Prefixignore',
    )
    suffixIgnore: Optional[List[str]] = Field(
        [],
        description='A list of suffixes to filter objects in the source to be ignored.',
        max_items=32,
        min_items=0,
        title='Suffixignore',
    )
    sourceType: Literal['sharepoint'] = Field(
        ...,
        description="The type of the source, which is 'sharepoint' for this model.",
        title='Sourcetype',
    )
    sharingUrl: Optional[str] = Field(
        None,
        description='The sharing URL of the Sharepoint / One-Drive directory.',
        title='Sharingurl',
    )


class TestConnectionResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    success: Optional[bool] = Field(
        True,
        description='Indicates if the connection test was successful.',
        title='Success',
    )


class TokenMetrics(BaseModel):
    totalTokens: Optional[int] = Field(
        0, description='Total number of tokens used.', title='Totaltokens'
    )
    totalCosts: Optional[str] = Field(
        '0.0', description='Total cost incurred for tokens.', title='Totalcosts'
    )


class Trigger(BaseModel):
    class Config:
        extra = Extra.forbid

    cron: str = Field(
        ...,
        description='Cron expression to schedule the trigger.',
        example='0 5 * * *',
        title='Cron',
    )
    timezone: Optional[str] = Field(
        'CET',
        description='Timezone for the cron expression.',
        example='CET',
        title='Timezone',
    )


class UpdateCollectionResponse(BaseModel):
    message: str = Field(
        ...,
        description='The message indicating the result of the operation.',
        title='Message',
    )


class UpdateSourceResponse(BaseModel):
    message: str = Field(
        ...,
        description='The message indicating the result of the operation.',
        title='Message',
    )


class UploadedDocumentMetadata(BaseModel):
    class Config:
        extra = Extra.forbid

    documentHash: str = Field(
        ..., description='The hash of the document', title='Documenthash'
    )
    documentName: str = Field(
        ..., description='The name of the document', title='Documentname'
    )
    lastModifiedTimestamp: str = Field(
        ...,
        description='The last modified timestamp of the document',
        title='Lastmodifiedtimestamp',
    )
    fileType: str = Field(
        ..., description='The file type of the document', title='Filetype'
    )
    documentSize: int = Field(
        ..., description='The size of the document in bytes', title='Documentsize'
    )


class UserRoleRequest(BaseModel):
    resource_name: str = Field(
        ..., description='Name of the resource', title='Resource Name'
    )
    role: str = Field(..., description='Name of the role to update', title='Role')
    user: str = Field(..., description='Username of the user', title='User')


class ValidationError(BaseModel):
    loc: List[Union[str, int]] = Field(..., title='Location')
    msg: str = Field(..., title='Message')
    type: str = Field(..., title='Error Type')


class DatabaseType1(Enum):
    postgresql_pgvector = 'postgresql-pgvector'


class VectorType(Enum):
    vector = 'vector'
    halfvec = 'halfvec'
    bit = 'bit'
    sparsevec = 'sparsevec'


class VectorDBPostgreSQL(BaseModel):
    databaseType: Literal['postgresql-pgvector'] = Field(..., title='Databasetype')
    vectorType: Optional[VectorType] = Field(
        'vector',
        description="The type of vector representation to use. One of:\n- 'vector': Single-precision dense vector (float32). Highest numeric fidelity (~4 bytes per dimension), compatible with most libraries, and recommended for training and high-accuracy similarity search.\n- 'halfvec': Half-precision dense vector (float16). Reduces memory and I/O (~2 bytes per dimension) at the cost of lower precision; suitable when memory bandwidth or storage is a bottleneck and slight accuracy loss is acceptable.\n- 'bit': Binary vector (bit-packed 0/1 or sign bits). Extremely compact and fast for large-scale retrieval using Hamming distance or bitwise ops. Typically derived via hashing or sign quantization; best for approximate similarity at very large index sizes.\n- 'sparsevec': Sparse vector storing only non-zero entries (e.g., as {index: value} or a list of (index, value) pairs). Efficient for very high-dimensional, mostly-zero features (e.g., bag-of-words), and commonly used with cosine or inner-product over sparse structures.",
        title='Vectortype',
    )


class SourceType6(Enum):
    website = 'website'


class WebsiteSourceProperties(BaseModel):
    class Config:
        extra = Extra.forbid

    prefix: Optional[List[str]] = Field(
        [],
        description='A list of prefixes to filter objects in the source.',
        max_items=32,
        min_items=0,
        title='Prefix',
    )
    suffix: Optional[List[str]] = Field(
        [],
        description='A list of suffixes to filter objects in the source.',
        max_items=32,
        min_items=0,
        title='Suffix',
    )
    prefixIgnore: Optional[List[str]] = Field(
        [],
        description='A list of prefixes to filter objects in the source to be ignored.',
        max_items=32,
        min_items=0,
        title='Prefixignore',
    )
    suffixIgnore: Optional[List[str]] = Field(
        [],
        description='A list of suffixes to filter objects in the source to be ignored.',
        max_items=32,
        min_items=0,
        title='Suffixignore',
    )
    sourceType: Literal['website'] = Field(
        ...,
        description="The type of the source, which is 'website' for this model.",
        title='Sourcetype',
    )
    urls: List[str] = Field(
        ...,
        description='A list of URLs of the websites to extract information from.',
        max_items=32,
        min_items=1,
        title='Urls',
    )
    includeSitemap: Optional[bool] = Field(
        False,
        description='Set this to true to search for the sitemap of a url and extract information from all urls in the sitemap.',
        title='Includesitemap',
    )
    authentication: Optional[Union[BasicAuthentication, BearerAuthentication]] = Field(
        None,
        description='Authentication configuration for accessing the website.',
        title='Authentication',
    )


class Plugins(BaseModel):
    __root__: DocumentSummaryPluginConfig = Field(..., discriminator='pluginType')


class CollectionConfigurationInput(BaseModel):
    collectionId: constr(
        regex=r'^[a-zA-Z_][a-zA-Z0-9_]*$', min_length=8, max_length=62
    ) = Field(
        ..., description='A unique identifier for the collection.', title='Collectionid'
    )
    description: Optional[str] = Field(
        None, description='Description of the collection.', title='Description'
    )
    projectNumber: Optional[constr(regex=r'^(00000|[1-9]\d{4}|1\d{5})$')] = Field(
        '00000',
        description='Project number related to the collection. This number is used to derive the business department (GB) and to allocate costs.',
        title='Projectnumber',
    )
    collectionType: Optional[Union[VectorDBPostgreSQL, S3VectorBucket]] = Field(
        None,
        description='The type of the collection. This defines which vector database is used and how it is configured.',
        discriminator='databaseType',
        title='Collectiontype',
    )
    sources: Optional[List[Source]] = Field(
        None,
        description='A list of source identifiers associated with the collection.',
        max_items=32,
        min_items=0,
        title='Sources',
    )
    plugins: Optional[List[Plugins]] = Field(
        [],
        description='Plugins that add additional features to the indexing process.',
        max_items=10,
        title='Plugins',
    )
    trigger: Optional[Trigger] = Field(
        None, description='Trigger configuration for the collection.'
    )
    chunking: Optional[CharacterChunker] = Field(
        None, description='Chunking configuration for the collection.'
    )
    embedding: Optional[Union[OpenAIEmbedding, BedrockEmbedding, MockEmbedding]] = (
        Field(
            None,
            description='Embedding configuration for the collection.',
            title='Embedding',
        )
    )
    searchIndex: Optional[SearchIndexHNSW] = Field(
        None, description='Index configuration for the collection.'
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Additional metadata for the data source.', title='Metadata'
    )
    public: Optional[bool] = Field(
        False,
        description='Flag indicating if the collection is publicly accessible.',
        title='Public',
    )
    allowFileUpload: Optional[bool] = Field(
        True,
        description='Flag indicating if file upload is allowed for this collection.',
        title='Allowfileupload',
    )
    datetimeCreation: Optional[str] = Field(
        None,
        description='Timestamp indicating when the collection was created.',
        title='Datetimecreation',
    )


class CollectionConfigurationOutput(BaseModel):
    collectionId: constr(
        regex=r'^[a-zA-Z_][a-zA-Z0-9_]*$', min_length=8, max_length=62
    ) = Field(
        ..., description='A unique identifier for the collection.', title='Collectionid'
    )
    description: Optional[str] = Field(
        None, description='Description of the collection.', title='Description'
    )
    projectNumber: Optional[constr(regex=r'^(00000|[1-9]\d{4}|1\d{5})$')] = Field(
        '00000',
        description='Project number related to the collection. This number is used to derive the business department (GB) and to allocate costs.',
        title='Projectnumber',
    )
    collectionType: Optional[Union[VectorDBPostgreSQL, S3VectorBucket]] = Field(
        None,
        description='The type of the collection. This defines which vector database is used and how it is configured.',
        discriminator='databaseType',
        title='Collectiontype',
    )
    sources: Optional[List[Source]] = Field(
        None,
        description='A list of source identifiers associated with the collection.',
        max_items=32,
        min_items=0,
        title='Sources',
    )
    plugins: Optional[List[Plugins]] = Field(
        [],
        description='Plugins that add additional features to the indexing process.',
        max_items=10,
        title='Plugins',
    )
    trigger: Optional[Trigger] = Field(
        None, description='Trigger configuration for the collection.'
    )
    chunking: Optional[CharacterChunker] = Field(
        None, description='Chunking configuration for the collection.'
    )
    embedding: Optional[Union[OpenAIEmbedding, BedrockEmbedding, MockEmbedding]] = (
        Field(
            None,
            description='Embedding configuration for the collection.',
            title='Embedding',
        )
    )
    searchIndex: Optional[SearchIndexHNSW] = Field(
        None, description='Index configuration for the collection.'
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Additional metadata for the data source.', title='Metadata'
    )
    public: Optional[bool] = Field(
        False,
        description='Flag indicating if the collection is publicly accessible.',
        title='Public',
    )
    allowFileUpload: Optional[bool] = Field(
        True,
        description='Flag indicating if file upload is allowed for this collection.',
        title='Allowfileupload',
    )
    datetimeCreation: Optional[str] = Field(
        None,
        description='Timestamp indicating when the collection was created.',
        title='Datetimecreation',
    )
    businessDepartment: str = Field(
        ...,
        description='Get the business department (GB) based on the project number.\n\nReturns\n-------\nstr\n    The business department (GB) derived from the project number.',
        title='Businessdepartment',
    )


class CollectionUsageItem(BaseModel):
    date: constr(regex=r'^\d{4}-\d{2}(-\d{2})?$') = Field(
        ..., description='Date in YYYY-MM-DD or YYYY-MM format', title='Date'
    )
    collectionId: constr(min_length=1, max_length=255) = Field(
        ..., description='Unique identifier for the collection', title='Collectionid'
    )
    index: Optional[IndexOperationStats] = Field(
        None, description='Index operation statistics'
    )
    query: Optional[QueryOperationStats] = Field(
        None, description='Query operation statistics'
    )


class CollectionUsageResponse(BaseModel):
    activeDays: int = Field(
        ..., description='Number of active days for the collection', title='Activedays'
    )
    inactiveDays: Optional[int] = Field(
        0,
        description='Number of inactive days for the collection',
        title='Inactivedays',
    )
    dateFirst: Optional[date] = Field(
        None, description='First date in the collected data', title='Datefirst'
    )
    dateLast: Optional[date] = Field(
        None, description='Last date in the collected data', title='Datelast'
    )
    summary: CollectionUsageSummary = Field(
        ..., description='Summary of the collection usage'
    )
    details: Optional[List[CollectionUsageItem]] = Field(
        None, description='List of collection usage details', title='Details'
    )


class DocumentMetadata(BaseModel):
    collectionId: str = Field(
        ...,
        description='Identifier for the collection containing the document',
        title='Collectionid',
    )
    documentId: str = Field(
        ..., description='Unique identifier for the document', title='Documentid'
    )
    datetimeExecution: str = Field(
        ...,
        description='Timestamp when the document was processed',
        title='Datetimeexecution',
    )
    documentHash: str = Field(
        ..., description='Hash value of the document content', title='Documenthash'
    )
    documentUrl: Optional[str] = Field(
        None, description='URL of the document if available', title='Documenturl'
    )
    documentName: str = Field(
        ..., description='Name of the document', title='Documentname'
    )
    documentDisplayName: Optional[str] = Field(
        None, description='Display name of the document', title='Documentdisplayname'
    )
    documentS3Reference: str = Field(
        ...,
        description='S3 reference path for the document',
        title='Documents3Reference',
    )
    documentSize: int = Field(
        ..., description='Size of the document in bytes', title='Documentsize'
    )
    fileType: str = Field(
        ..., description='Type of the document file', title='Filetype'
    )
    indexRunId: str = Field(
        ...,
        description='Identifier for the index run that processed the document',
        title='Indexrunid',
    )
    lastModifiedTimestamp: Optional[str] = Field(
        None,
        description='Last modification timestamp of the document',
        title='Lastmodifiedtimestamp',
    )
    numberOfFragments: Optional[int] = Field(
        None,
        description='Number of fragments the document was split into',
        title='Numberoffragments',
    )
    plugins: Optional[List[PluginInfo]] = Field(
        None, description='List of plugins that processed the document', title='Plugins'
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Additional metadata associated with the document',
        title='Metadata',
    )
    sourceId: str = Field(
        ..., description='Identifier for the source of the document', title='Sourceid'
    )


class Fragment(BaseModel):
    class Config:
        extra = Extra.forbid

    fragmentId: str = Field(
        ..., description='The ID of the fragment', title='Fragmentid'
    )
    content: str = Field(
        ..., description='The content of the fragment', title='Content'
    )
    vector: List[float] = Field(
        ..., description='The vector representation of the fragment', title='Vector'
    )
    embeddingModel: str = Field(
        ...,
        description='The embedding model used for this fragment',
        title='Embeddingmodel',
    )
    sourceId: str = Field(
        ..., description='The source ID of the fragment', title='Sourceid'
    )
    indexRunId: str = Field(
        ...,
        description='The index run ID associated with this fragment',
        title='Indexrunid',
    )
    collectionId: str = Field(
        ...,
        description='The collection ID this fragment belongs to',
        title='Collectionid',
    )
    documentId: str = Field(
        ..., description='The document ID this fragment belongs to', title='Documentid'
    )
    documentName: str = Field(
        ..., description='The name of the document', title='Documentname'
    )
    documentUrl: Optional[str] = Field(
        None, description='URL of the original document', title='Documenturl'
    )
    documentUrlReference: Optional[str] = Field(
        None,
        description='URL of the reference document in AI Knowledge',
        title='Documenturlreference',
    )
    documentDisplayName: Optional[str] = Field(
        None, description='Display name of the document', title='Documentdisplayname'
    )
    lastModifiedTimestamp: str = Field(
        ...,
        description='The timestamp when the fragment was last modified',
        title='Lastmodifiedtimestamp',
    )
    metadata: Optional[FragmentMetadata] = Field(
        None, description='The metadata of the fragment.'
    )
    extendedContext: Optional[Dict[str, Any]] = Field(
        None,
        description='Extended context information if available',
        title='Extendedcontext',
    )


class HTTPValidationError(BaseModel):
    detail: Optional[List[ValidationError]] = Field(None, title='Detail')


class ListFragmentsResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    Count: int = Field(
        ..., description='The number of items in the list', title='Count'
    )
    ScannedCount: int = Field(
        ..., description='The number of items scanned', title='Scannedcount'
    )
    TotalCount: int = Field(
        ...,
        description='The total number of items for the given query.',
        title='Totalcount',
    )
    Items: List[Fragment] = Field(
        ..., description='The list of fragments', max_items=1000, title='Items'
    )
    NextToken: Optional[str] = Field(
        None, description='The next token to retrieve the next page.', title='Nexttoken'
    )


class ListIndexedDocumentsResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    Count: int = Field(
        ..., description='The number of items in the list', title='Count'
    )
    ScannedCount: int = Field(
        ..., description='The number of items scanned', title='Scannedcount'
    )
    TotalCount: int = Field(
        ...,
        description='The total number of items for the given query.',
        title='Totalcount',
    )
    Items: List[DocumentMetadata] = Field(
        ..., description='The list of collections', max_items=1000, title='Items'
    )
    NextToken: Optional[str] = Field(
        None, description='The next token to retrieve the next page.', title='Nexttoken'
    )


class ListUploadedDocumentsResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    Count: int = Field(
        ..., description='The number of items in the list', title='Count'
    )
    ScannedCount: int = Field(
        ..., description='The number of items scanned', title='Scannedcount'
    )
    TotalCount: int = Field(
        ...,
        description='The total number of items for the given query.',
        title='Totalcount',
    )
    Items: List[UploadedDocumentMetadata] = Field(
        ..., description='The list of collections', max_items=1000, title='Items'
    )
    NextToken: Optional[str] = Field(
        None, description='The next token to retrieve the next page.', title='Nexttoken'
    )


class ProcessingMetrics(BaseModel):
    documentMetrics: Optional[DocumentMetrics] = None
    tokenMetrics: Optional[TokenMetrics] = None


class SourceConfigurationInput(BaseModel):
    sourceId: constr(regex=r'^[a-zA-Z0-9-_]+$', min_length=8, max_length=255) = Field(
        ..., description='A unique identifier for the data source.', title='Sourceid'
    )
    description: Optional[str] = Field(
        None, description='Description of the data source.', title='Description'
    )
    properties: Union[
        WebsiteSourceProperties,
        S3SourcePropertiesInput,
        GithubSourcePropertiesInput,
        SharepointSourcePropertiesInput,
    ] = Field(
        ...,
        description='Properties specific to the data source type.',
        discriminator='sourceType',
        title='Properties',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Additional metadata for the data source.', title='Metadata'
    )
    public: Optional[bool] = Field(
        False,
        description='Flag indicating if the source is publically accessible.',
        title='Public',
    )


class SourceConfigurationOutput(BaseModel):
    sourceId: constr(regex=r'^[a-zA-Z0-9-_]+$', min_length=8, max_length=255) = Field(
        ..., description='A unique identifier for the data source.', title='Sourceid'
    )
    description: Optional[str] = Field(
        None, description='Description of the data source.', title='Description'
    )
    properties: Union[
        WebsiteSourceProperties,
        S3SourcePropertiesOutput,
        GithubSourcePropertiesOutput,
        SharepointSourcePropertiesOutput,
    ] = Field(
        ...,
        description='Properties specific to the data source type.',
        discriminator='sourceType',
        title='Properties',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Additional metadata for the data source.', title='Metadata'
    )
    public: Optional[bool] = Field(
        False,
        description='Flag indicating if the source is publically accessible.',
        title='Public',
    )


class IndexRunItem(BaseModel):
    indexRunId: str = Field(..., description='The index run ID.', title='Indexrunid')
    datetimeExecution: str = Field(
        ...,
        description='The datetime (isoformat) when the run was executed.',
        example='2025-02-13T09:44:22.665141+00:00',
        title='Datetimeexecution',
    )
    taskStatus: TaskStatus = Field(
        ..., description='The status of the task', title='Taskstatus'
    )
    collectionId: str = Field(
        ..., description='The collection ID of the index run.', title='Collectionid'
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Additional metadata for the index run.', title='Metadata'
    )
    trigger: Trigger1 = Field(
        ...,
        description='Specifies if the index run was executed manually or scheduled.',
        title='Trigger',
    )
    traceId: Optional[str] = Field(
        None,
        description='Trace ID for distributed tracing. If not provided, it will be set to None.',
        title='Traceid',
    )
    metrics: Optional[ProcessingMetrics] = Field(
        None, description='Processing metrics for the index run.'
    )


class ListIndexRunsResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    Count: int = Field(
        ..., description='Number of items returned in the response', title='Count'
    )
    ScannedCount: int = Field(
        ...,
        description='Number of items evaluated in the database',
        title='Scannedcount',
    )
    TotalCount: int = Field(
        ...,
        description='Total number of items matching the query criteria',
        title='Totalcount',
    )
    Items: List[IndexRunItem] = Field(
        ..., description='List of index run items', max_items=1000, title='Items'
    )
    NextToken: Optional[str] = Field(
        None,
        description='Token for retrieving the next page of results',
        title='Nexttoken',
    )
    NextScheduledIndexRun: Optional[str] = Field(
        None,
        description='Datetime of the next scheduled index run',
        title='Nextscheduledindexrun',
    )
